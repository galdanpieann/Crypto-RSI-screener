<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Crypto RSI MTF Screener — 4h calc sampled on D1 (last 4 closed days)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f1115; --panel: #151924; --text: #e6e6e6; --muted: #a0a7b4;
      --accent: #3ea6ff; --good: #2bb673; --bad: #e5534b; --warn: #ffbf3f;
      --chip: #0e121b; --chip-b: #2a2f3a;
    }
    body { background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif; margin: 0; padding: 24px; }
    h1 { margin: 0 0 8px; font-size: 20px; }
    .sub { color: var(--muted); margin-bottom: 16px; font-size: 13px; }
    .panel { background: var(--panel); border-radius: 10px; padding: 16px; box-shadow: 0 2px 10px rgba(0,0,0,0.35); }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .ctrl { display: inline-flex; gap: 8px; align-items: center; background: var(--chip); border: 1px solid var(--chip-b); padding: 8px 10px; border-radius: 8px; }
    select, input[type="checkbox"] { accent-color: var(--accent); }
    select, input[type="text"], input[type="number"] { background: var(--chip); color: var(--text); border: 1px solid var(--chip-b); border-radius: 6px; padding: 6px 8px; outline: none; width: auto; }
    input[disabled] { opacity: .7; }
    button { background: var(--accent); border: none; color: #061018; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-weight: 600; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    thead th { text-align: left; color: var(--muted); font-weight: 600; border-bottom: 1px solid #2a2f3a; padding: 10px 8px; cursor: pointer; user-select: none; white-space: nowrap; }
    tbody td { border-bottom: 1px solid #202533; padding: 10px 8px; vertical-align: middle; white-space: nowrap; }
    .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .tag { font-size: 11px; color: #0b141a; background: #9ad3ff; padding: 2px 6px; border-radius: 999px; }
    .green { color: var(--good); } .red { color: var(--bad); } .yellow { color: var(--warn); }
    .spark { width: 120px; height: 28px; }
    .note { color: var(--muted); font-size: 12px; margin-top: 8px; }
    .loading { color: var(--muted); }
    .pill { border: 1px solid var(--chip-b); background: var(--chip); border-radius: 6px; padding: 2px 6px; font-size: 11px; display: inline-flex; gap: 4px; align-items: center; }
    .up { color: var(--good); } .down { color: var(--bad); }
    .cellpills { display: inline-flex; gap: 6px; flex-wrap: wrap; }
    .status { display: inline-block; min-width: 12px; min-height: 12px; border-radius: 999px; }
    a { color: #7ec9ff; text-decoration: none; } a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <h1>Crypto RSI MTF Screener — 4h calc sampled on D1 (last 4 closed days)</h1>
  <div class="sub">
    - RSI Length: 14 (source: close, fixed) • Calculation timeframe: 4 hours • Signals evaluated on D1 by sampling the last closed 4h candle of each day (TradingView “Wait for timeframe closes” behavior, Wilder’s RSI).<br />
    - Shows RSI crosses (30 / 50 / 70) for the last 4 fully closed daily bars: D‑3, D‑2, D‑1, D‑0.
  </div>

  <div class="panel" style="margin-bottom:14px">
    <div class="row">
      <div class="ctrl" title="RSI period is fixed to 14">
        <label>RSI Length</label>
        <input type="number" value="14" disabled />
      </div>
      <div class="ctrl">
        <label for="levelFilter">Level filter</label>
        <select id="levelFilter" title="Require a specific level or allow any">
          <option value="any" selected>Any (30/50/70)</option>
          <option value="30">30 only</option>
          <option value="50">50 only</option>
          <option value="70">70 only</option>
        </select>
      </div>
      <div class="ctrl">
        <input type="checkbox" id="onlyCrosses" checked />
        <label for="onlyCrosses">Only show symbols with a cross in the last 4 closed days</label>
      </div>
      <div class="ctrl">
        <label for="mcap">Min Market Cap</label>
        <select id="mcap">
          <option value="0" selected>No filter</option>
          <option value="5">≥ $5M</option>
          <option value="200">≥ $200M</option>
          <option value="500">≥ $500M</option>
          <option value="1000">≥ $1B</option>
        </select>
      </div>
      <div class="ctrl" title="Limits displayed rows only">
        <label for="limit">Max Rows</label>
        <select id="limit">
          <option>50</option>
          <option>100</option>
          <option>200</option>
          <option selected>500</option>
        </select>
      </div>
      <button id="calc">Calculate</button>
      <span id="status" class="loading">Idle</span>
    </div>
    <div class="note">
      Cross per day is determined by comparing the 4h‑computed RSI (Wilder) sampled at the last closed 4h bar of that day to the sample of the prior day (TV-style on a D1 chart with Timeframe=4h and “Wait for timeframe closes”).
    </div>
  </div>

  <div class="panel">
    <table id="tbl">
      <thead>
        <tr>
          <th data-key="symbol">Symbol</th>
          <th data-key="rsi" data-num>RSI(14) D1</th>
          <th data-key="close" data-num>Last Close</th>
          <th data-key="chg" data-num>24h</th>
          <th data-key="mcap" data-num>Market Cap</th>
          <th data-key="time" data-num>Last D1 Close</th>
          <th>D‑3</th>
          <th>D‑2</th>
          <th>D‑1</th>
          <th>D‑0</th>
          <th>Sparkline (D1)</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
    <div class="note" id="count"></div>
  </div>

  <script>
    const fmtUSD = n => {
      if (n == null || isNaN(n)) return "-";
      if (n >= 1e12) return "$" + (n/1e12).toFixed(2) + "T";
      if (n >= 1e9) return "$" + (n/1e9).toFixed(2) + "B";
      if (n >= 1e6) return "$" + (n/1e6).toFixed(2) + "M";
      if (n >= 1e3) return "$" + (n/1e3).toFixed(2) + "K";
      return "$" + Number(n).toFixed(4);
    };
    const fmtNum = n => (n == null || isNaN(n) ? "-" : n.toLocaleString(undefined, {maximumFractionDigits: 6}));
    const fmtPct = n => (n == null || isNaN(n) ? "-" : (n >= 0 ? "+" : "") + n.toFixed(2) + "%");
    const utcDateTime = ms => new Date(ms).toISOString().replace("T", " ").replace(/\..+/, " UTC");

    function drawSpark(canvas, arr) {
      const ctx = canvas.getContext("2d");
      const w = canvas.width = canvas.clientWidth;
      const h = canvas.height = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);
      if (!arr || arr.length < 2) return;
      const min = Math.min(...arr);
      const max = Math.max(...arr);
      const norm = v => (h - 2) - ((v - min) / (max - min || 1)) * (h - 4);
      ctx.lineWidth = 2;
      const grad = ctx.createLinearGradient(0,0,w,0);
      const lastUp = arr[arr.length - 1] >= arr[0];
      grad.addColorStop(0, lastUp ? "#46d990" : "#ff7e7e");
      grad.addColorStop(1, lastUp ? "#12a66d" : "#d34242");
      ctx.strokeStyle = grad;
      ctx.beginPath();
      arr.forEach((v, i) => {
        const x = (i/(arr.length-1)) * (w-4) + 2;
        const y = norm(v);
        if (i === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.stroke();
    }

    // Wilder's RSI (source: close)
    function rsiSeriesWilder(closes, period = 14) {
      const N = closes.length;
      const out = new Array(N).fill(null);
      if (N < period + 1) return out;

      const gains = new Array(N - 1);
      const losses = new Array(N - 1);
      for (let i = 0; i < N - 1; i++) {
        const d = closes[i+1] - closes[i];
        gains[i] = d > 0 ? d : 0;
        losses[i] = d < 0 ? -d : 0;
      }

      // Initial averages
      let avgGain = 0, avgLoss = 0;
      for (let i = 0; i < period; i++) {
        avgGain += gains[i];
        avgLoss += losses[i];
      }
      avgGain /= period;
      avgLoss /= period;

      // First RSI value at index = period
      out[period] = avgLoss === 0
        ? (avgGain === 0 ? 50 : 100)
        : 100 - (100 / (1 + (avgGain / avgLoss)));

      // Wilder smoothing
      for (let i = period; i < gains.length; i++) {
        avgGain = (avgGain * (period - 1) + gains[i]) / period;
        avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
        const idx = i + 1; // RSI aligns to close index
        out[idx] = avgLoss === 0
          ? (avgGain === 0 ? 50 : 100)
          : 100 - (100 / (1 + (avgGain / avgLoss)));
      }

      return out;
    }

    function crossDir(prev, curr, level) {
      if (prev == null || curr == null) return null;
      if (prev < level && curr >= level) return "up";
      if (prev > level && curr <= level) return "down";
      return null;
    }

    async function fetchJson(url, init={}, tries=3, retryDelay=600) {
      for (let t=0; t<tries; t++) {
        try {
          const r = await fetch(url, init);
          if (!r.ok) throw new Error("HTTP " + r.status + " " + (await r.text()));
          return await r.json();
        } catch (e) {
          if (t === tries-1) throw e;
          await new Promise(res => setTimeout(res, retryDelay * (t+1)));
        }
      }
    }

    async function getBinancePerpUSDT() {
      const info = await fetchJson("https://fapi.binance.com/fapi/v1/exchangeInfo");
      const syms = info.symbols
        .filter(s => s.contractType === "PERPETUAL" && s.quoteAsset === "USDT" && s.status === "TRADING")
        .map(s => ({ symbol: s.symbol, base: s.baseAsset, quote: s.quoteAsset }));
      const bad = /UP|DOWN|BULL|BEAR|[0-9]{3,}|HALF|HEDGE|ETHFI0|TEST|DOM/i;
      return syms.filter(s => !bad.test(s.base));
    }

    async function getCoinGeckoMcaps(minUSDm = 0) {
      if (!minUSDm) return { map: new Map(), pass: () => true };
      const minCap = minUSDm * 1e6;
      const pages = [1, 2, 3];
      const results = [];
      for (const p of pages) {
        const url = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=250&page=${p}&price_change_percentage=24h`;
        results.push(...await fetchJson(url));
      }
      const map = new Map();
      for (const c of results) {
        if (!c.symbol || c.market_cap == null) continue;
        const key = String(c.symbol).toUpperCase();
        const prev = map.get(key);
        if (!prev || (c.market_cap || 0) > (prev.market_cap || 0)) {
          map.set(key, c);
        }
      }
      return {
        map,
        pass: sym => {
          const it = map.get(String(sym).toUpperCase());
          return it && (it.market_cap || 0) >= minCap;
        }
      };
    }

    async function getKlines(symbol, interval="1d", limit=260) {
      const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
      const rows = await fetchJson(url);
      return rows.map(r => ({
        openTime: r[0], open: +r[1], high: +r[2], low: +r[3], close: +r[4], volume: +r[5], closeTime: r[6]
      }));
    }

    async function pool(items, limit, worker) {
      const ret = [];
      let i = 0, active = 0;
      return new Promise((resolve) => {
        const next = () => {
          if (i >= items.length && active === 0) return resolve(ret);
          while (active < limit && i < items.length) {
            const idx = i++;
            active++;
            Promise.resolve(worker(items[idx], idx))
              .then(v => (ret[idx] = v))
              .catch(e => (ret[idx] = { error: String(e) }))
              .finally(() => { active--; next(); });
          }
        };
        next();
      });
    }

    function lastIndexAtOrBefore(arr, time) {
      let lo = 0, hi = arr.length - 1, ans = -1;
      while (lo <= hi) {
        const mid = (lo + hi) >> 1;
        if (arr[mid].closeTime <= time) { ans = mid; lo = mid + 1; }
        else hi = mid - 1;
      }
      return ans;
    }

    function renderPills(crosses) {
      if (!crosses || crosses.length === 0) return "<span class='pill'>—</span>";
      const parts = crosses.map(c => {
        const dir = c.startsWith("up") ? "up" : "down";
        const lvl = c.replace("up","").replace("down","");
        const arrow = dir === "up" ? "↑" : "↓";
        return `<span class="pill ${dir}" title="RSI ${dir} cross ${lvl}">${arrow} ${lvl}</span>`;
      });
      return `<span class="cellpills">${parts.join("")}</span>`;
    }

    let sortKey = "rsi";
    let sortAsc = false;
    function applySort(rows) {
      const key = sortKey;
      const asc = sortAsc ? 1 : -1;
      rows.sort((a,b) => {
        const va = a[key], vb = b[key];
        if (va == null && vb == null) return 0;
        if (va == null) return 1;
        if (vb == null) return -1;
        if (typeof va === "number" && typeof vb === "number") return asc * (va - vb);
        return asc * String(va).localeCompare(String(vb));
      });
    }

    async function run() {
      const status = document.getElementById("status");
      const tbody = document.querySelector("#tbl tbody");
      const mcapSel = document.getElementById("mcap");
      const limitSel = document.getElementById("limit");
      const onlyCrossesEl = document.getElementById("onlyCrosses");
      const levelFilter = document.getElementById("levelFilter").value;

      const period = 14;
      const minUSDm = Number(mcapSel.value);
      const maxRows = Number(limitSel.value);

      status.textContent = "Loading symbols …";
      const binanceSyms = await getBinancePerpUSDT();

      status.textContent = "Loading market caps …";
      let mcap = { map: new Map(), pass: () => true };
      try { mcap = await getCoinGeckoMcaps(minUSDm); } catch (_) {}

      const candidates = binanceSyms.filter(s => mcap.pass(s.base));
      status.textContent = `Fetching klines for ${candidates.length} symbols …`;

      const results = await pool(candidates, 5, async s => {
        const [d1, h4] = await Promise.all([
          getKlines(s.symbol, "1d", 260),
          getKlines(s.symbol, "4h", 900)
        ]);
        return { s, d1, h4 };
      });

      const rows = [];
      for (const item of results) {
        if (!item || item.error) continue;
        const d1 = item.d1, h4 = item.h4;
        if (!d1 || d1.length < period + 6 || !h4 || h4.length < period + 50) continue;

        // Last five closed daily bars: D-4..D-0 to get 4 comparisons
        const nD = d1.length;
        const D0 = d1[nD - 1], D1 = d1[nD - 2], D2 = d1[nD - 3], D3 = d1[nD - 4], D4 = d1[nD - 5];
        if (!D4) continue;

        // D1 RSI (Wilder) at D0 for display
        const closesD1 = d1.map(k => k.close);
        const rsiD1Series = rsiSeriesWilder(closesD1, period);
        const rsiD1 = rsiD1Series[rsiD1Series.length - 1];

        // 4h RSI (Wilder) series for sampling
        const closesH4 = h4.map(k => k.close);
        const rsiH4 = rsiSeriesWilder(closesH4, period);

        // Sample the last closed 4h <= daily close
        const iD4 = lastIndexAtOrBefore(h4, D4.closeTime);
        const iD3 = lastIndexAtOrBefore(h4, D3.closeTime);
        const iD2 = lastIndexAtOrBefore(h4, D2.closeTime);
        const iD1 = lastIndexAtOrBefore(h4, D1.closeTime);
        const iD0 = lastIndexAtOrBefore(h4, D0.closeTime);
        if ([iD4,iD3,iD2,iD1,iD0].some(i => i < 0)) continue;

        const sD4 = rsiH4[iD4];
        const sD3 = rsiH4[iD3];
        const sD2 = rsiH4[iD2];
        const sD1 = rsiH4[iD1];
        const sD0 = rsiH4[iD0];

        function crosses(prev, curr) {
          const out = [];
          const c30 = crossDir(prev, curr, 30);
          const c50 = crossDir(prev, curr, 50);
          const c70 = crossDir(prev, curr, 70);
          if (c30) out.push(c30 + "30");
          if (c50) out.push(c50 + "50");
          if (c70) out.push(c70 + "70");
          return out;
        }
        const cD3 = crosses(sD4, sD3);
        const cD2 = crosses(sD3, sD2);
        const cD1 = crosses(sD2, sD1);
        const cD0 = crosses(sD1, sD0);

        const matchesLevel = (arr) => {
          if (!arr || arr.length === 0) return false;
          if (levelFilter === "any") return true;
          return arr.some(x => x.endsWith(levelFilter));
        };
        const anyMatch = matchesLevel(cD3) || matchesLevel(cD2) || matchesLevel(cD1) || matchesLevel(cD0);

        const cg = mcap.map.get(item.s.base.toUpperCase());
        const mcapVal = cg ? cg.market_cap : null;
        const chg = cg && typeof cg.price_change_percentage_24h === "number"
          ? cg.price_change_percentage_24h
          : ((D0.close - D1.close) / D1.close) * 100;

        const row = {
          symbol: item.s.symbol,
          base: item.s.base,
          rsi: rsiD1,
          close: D0.close,
          chg,
          mcap: mcapVal,
          time: D0.closeTime,
          spark: closesD1.slice(-30),
          D3: cD3, D2: cD2, D1: cD1, D0: cD0,
          anyMatch
        };

        if (!onlyCrossesEl.checked || anyMatch) rows.push(row);
      }

      applySort(rows);
      const limited = rows.slice(0, maxRows);

      const tbodyEl = document.querySelector("#tbl tbody");
      tbodyEl.innerHTML = "";
      for (const r of limited) {
        const tr = document.createElement("tr");
        const tvSym = `${r.base}USDT.P`;
        const tvUrl = `https://www.tradingview.com/chart/?symbol=BINANCE:${encodeURIComponent(tvSym)}`;
        const binUrl = `https://www.binance.com/en/futures/${encodeURIComponent(r.symbol)}`;
        const rsiClass = r.rsi != null ? (r.rsi <= 30 ? "green" : r.rsi >= 70 ? "red" : "yellow") : "";
        tr.innerHTML = `
          <td>
            <div style="display:flex;align-items:center;gap:8px;">
              <span class="status" style="background:${r.chg >= 0 ? 'var(--good)' : 'var(--bad)'}"></span>
              <a href="${binUrl}" target="_blank" rel="noopener">${r.symbol}</a>
              <span class="tag">USDT.P</span>
              <a href="${tvUrl}" target="_blank" rel="noopener" title="Open in TradingView">TV</a>
            </div>
          </td>
          <td class="mono ${rsiClass}">${r.rsi == null ? "-" : r.rsi.toFixed(2)}</td>
          <td class="mono">${fmtNum(r.close)}</td>
          <td class="mono ${r.chg >= 0 ? 'green' : 'red'}">${fmtPct(r.chg)}</td>
          <td class="mono">${r.mcap == null ? "—" : fmtUSD(r.mcap)}</td>
          <td class="mono">${utcDateTime(r.time)}</td>
          <td>${renderPills(r.D3)}</td>
          <td>${renderPills(r.D2)}</td>
          <td>${renderPills(r.D1)}</td>
          <td>${renderPills(r.D0)}</td>
          <td><canvas class="spark"></canvas></td>
        `;
        tbodyEl.appendChild(tr);
        drawSpark(tr.querySelector("canvas"), r.spark);
      }

      document.getElementById("count").textContent =
        `Showing ${limited.length} of ${rows.length} matches (scanned ${candidates.length}). RSI(14) on 4h (Wilder), sampled at daily boundary.`;
      status.textContent = `Done at ${utcDateTime(Date.now())}`;
    }

    document.querySelectorAll("#tbl thead th").forEach(th => {
      th.addEventListener("click", () => {
        const key = th.getAttribute("data-key");
        if (!key) return;
        if (sortKey === key) sortAsc = !sortAsc;
        else { sortKey = key; sortAsc = key === "symbol"; }
        run().catch(e => {
          document.getElementById("status").textContent = "Error: " + e.message;
        });
      });
    });

    document.getElementById("calc").addEventListener("click", () => {
      document.getElementById("status").textContent = "Calculating…";
      run().catch(e => {
        document.getElementById("status").textContent = "Error: " + e.message;
      });
    });

    document.getElementById("status").textContent = "Click Calculate to scan last 4 closed days";
  </script>
</body>
</html>
