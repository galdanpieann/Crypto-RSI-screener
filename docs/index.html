<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Crypto RSI MTF Screener — H4 crosses mapped to D1</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f1115; --panel: #151924; --text: #e6e6e6; --muted: #a0a7b4;
      --accent: #3ea6ff; --good: #2bb673; --bad: #e5534b; --warn: #ffbf3f;
      --chip: #0e121b; --chip-b: #2a2f3a;
    }
    body { background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif; margin: 0; padding: 24px; }
    h1 { margin: 0 0 8px; font-size: 20px; }
    .sub { color: var(--muted); margin-bottom: 16px; font-size: 13px; }
    .panel { background: var(--panel); border-radius: 10px; padding: 16px; box-shadow: 0 2px 10px rgba(0,0,0,0.35); }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .ctrl { display: inline-flex; gap: 8px; align-items: center; background: var(--chip); border: 1px solid var(--chip-b); padding: 8px 10px; border-radius: 8px; }
    select, input[type="checkbox"], input[type="number"] { accent-color: var(--accent); }
    select, input[type="text"], input[type="number"] { background: var(--chip); color: var(--text); border: 1px solid var(--chip-b); border-radius: 6px; padding: 6px 8px; outline: none; width: auto; }
    button { background: var(--accent); border: none; color: #061018; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-weight: 600; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    thead th { text-align: left; color: var(--muted); font-weight: 600; border-bottom: 1px solid #2a2f3a; padding: 10px 8px; cursor: pointer; user-select: none; white-space: nowrap; }
    tbody td { border-bottom: 1px solid #202533; padding: 10px 8px; vertical-align: middle; white-space: nowrap; }
    .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .tag { font-size: 11px; color: #0b141a; background: #9ad3ff; padding: 2px 6px; border-radius: 999px; }
    .green { color: var(--good); } .red { color: var(--bad); } .yellow { color: var(--warn); }
    .spark { width: 120px; height: 28px; }
    .note { color: var(--muted); font-size: 12px; margin-top: 8px; }
    .loading { color: var(--muted); }
    .chip { background: var(--chip); border: 1px solid var(--chip-b); padding: 4px 8px; border-radius: 999px; color: var(--muted); font-size: 12px; }
    a { color: #7ec9ff; text-decoration: none; } a:hover { text-decoration: underline; }
    .status { display: inline-block; min-width: 12px; min-height: 12px; border-radius: 999px; }
    .pill { border: 1px solid var(--chip-b); background: var(--chip); border-radius: 6px; padding: 2px 6px; font-size: 11px; }
    .up { color: var(--good); } .down { color: var(--bad); }
  </style>
</head>
<body>
  <h1>Crypto RSI MTF Screener — H4 crosses mapped to D1</h1>
  <div class="sub">
    RSI length: 14 (source: close). Multi-timeframe: detect H4 RSI crosses (30 / 50 / 70) that occurred during the last closed D1 candle, and report them on the daily row (daily close).
  </div>

  <div class="panel" style="margin-bottom:14px">
    <div class="row">
      <div class="ctrl">
        <label for="mode">Mode</label>
        <select id="mode" title="Choose how crosses are computed">
          <option value="h4_in_d1" selected>H4 RSI crosses → mapped to D1 day</option>
          <option value="d1_only">D1 RSI crosses (no MTF)</option>
        </select>
      </div>
      <div class="ctrl" title="RSI period (length) in candles">
        <label for="period">RSI Length</label>
        <input id="period" type="number" value="14" min="2" max="100" step="1" />
      </div>
      <div class="ctrl">
        <input type="checkbox" id="onlyCrosses" />
        <label for="onlyCrosses">Only show symbols with a cross in the selected mode</label>
      </div>
      <div class="ctrl">
        <label for="mcap">Min Market Cap</label>
        <select id="mcap">
          <option value="200">≥ $200M</option>
          <option value="500">≥ $500M</option>
          <option value="1000">≥ $1B</option>
          <option value="5">≥ $5M</option>
          <option value="0">No filter</option>
        </select>
      </div>
      <div class="ctrl" title="Limit how many rows are displayed (does not change how many markets are scanned)">
        <label for="limit">Max Rows</label>
        <select id="limit">
          <option>50</option>
          <option selected>100</option>
          <option>200</option>
          <option>500</option>
        </select>
      </div>
      <button id="calc">Calculate</button>
      <span id="status" class="loading">Idle</span>
    </div>
    <div class="note">
      Mode “H4 RSI crosses → mapped to D1 day”: Uses 4h candles to detect RSI(14) level crossings inside the last fully closed daily candle. The RSI value shown is RSI(14) on D1 (daily close).
    </div>
  </div>

  <div class="panel">
    <table id="tbl">
      <thead>
        <tr>
          <th data-key="symbol">Symbol</th>
          <th id="thRsi" data-key="rsi" data-num>RSI(14) D1</th>
          <th data-key="close" data-num>Last Close</th>
          <th data-key="chg" data-num>24h</th>
          <th data-key="mcap" data-num>Market Cap</th>
          <th data-key="time" data-num>Daily Close Time</th>
          <th data-key="crossScore" data-num>Cross 30</th>
          <th data-key="crossScore" data-num>Cross 50</th>
          <th data-key="crossScore" data-num>Cross 70</th>
          <th>Sparkline (D1)</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
    <div class="note" id="count"></div>
  </div>

  <script>
    const fmtUSD = n => {
      if (n == null || isNaN(n)) return "-";
      if (n >= 1e12) return "$" + (n/1e12).toFixed(2) + "T";
      if (n >= 1e9) return "$" + (n/1e9).toFixed(2) + "B";
      if (n >= 1e6) return "$" + (n/1e6).toFixed(2) + "M";
      if (n >= 1e3) return "$" + (n/1e3).toFixed(2) + "K";
      return "$" + Number(n).toFixed(4);
    };
    const fmtNum = n => (n == null || isNaN(n) ? "-" : n.toLocaleString(undefined, {maximumFractionDigits: 6}));
    const fmtPct = n => (n == null || isNaN(n) ? "-" : (n >= 0 ? "+" : "") + n.toFixed(2) + "%");
    const utcDateTime = ms => new Date(ms).toISOString().replace("T", " ").replace(/\..+/, " UTC");

    function drawSpark(canvas, arr) {
      const ctx = canvas.getContext("2d");
      const w = canvas.width = canvas.clientWidth;
      const h = canvas.height = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);
      if (!arr || arr.length < 2) return;
      const min = Math.min(...arr);
      const max = Math.max(...arr);
      const norm = v => (h - 2) - ((v - min) / (max - min || 1)) * (h - 4);
      ctx.lineWidth = 2;
      const grad = ctx.createLinearGradient(0,0,w,0);
      const lastUp = arr[arr.length - 1] >= arr[0];
      grad.addColorStop(0, lastUp ? "#46d990" : "#ff7e7e");
      grad.addColorStop(1, lastUp ? "#12a66d" : "#d34242");
      ctx.strokeStyle = grad;
      ctx.beginPath();
      arr.forEach((v, i) => {
        const x = (i/(arr.length-1)) * (w-4) + 2;
        const y = norm(v);
        if (i === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.stroke();
    }

    // Simple moving-average RSI (source: close) for a single point
    function rsiAt(closes, endIndexExclusive, period = 14) {
      if (!closes || endIndexExclusive < period + 1) return null;
      const recent = closes.slice(endIndexExclusive - (period + 1), endIndexExclusive);
      let gains = 0, losses = 0;
      for (let i = 0; i < period; i++) {
        const diff = recent[i+1] - recent[i];
        if (diff > 0) gains += diff; else losses -= diff;
      }
      const avgGain = gains / period;
      const avgLoss = losses / period;
      if (avgLoss === 0 && avgGain === 0) return 50;
      if (avgLoss === 0) return 100;
      const rs = avgGain / avgLoss;
      return 100 - (100 / (1 + rs));
    }

    // Sliding-window RSI series (same simple method, efficient)
    function rsiSeries(closes, period = 14) {
      const N = closes.length;
      const out = new Array(N).fill(null);
      if (N < period + 1) return out;
      const diffs = new Array(N - 1);
      for (let i = 0; i < N - 1; i++) diffs[i] = closes[i+1] - closes[i];
      let g = 0, l = 0;
      for (let k = 0; k < period; k++) {
        const d = diffs[k];
        if (d > 0) g += d; else l -= d;
      }
      const setRsi = (j) => {
        const avgG = g / period;
        const avgL = l / period;
        out[j] = avgL === 0 && avgG === 0 ? 50 : (avgL === 0 ? 100 : (100 - (100 / (1 + (avgG / avgL)))));
      };
      // RSI at index = period corresponds to window diffs[0..period-1] -> closes[0..period]
      setRsi(period);
      for (let j = period + 1; j < N; j++) {
        const oldD = diffs[j - period - 1];
        const newD = diffs[j - 1];
        if (oldD > 0) g -= oldD; else l += oldD; // oldD negative -> losses subtracting becomes adding negative
        if (newD > 0) g += newD; else l -= newD;
        setRsi(j);
      }
      return out;
    }

    function crossDir(prev, curr, level) {
      if (prev == null || curr == null) return null;
      if (prev < level && curr >= level) return "up";
      if (prev > level && curr <= level) return "down";
      return null;
    }

    async function fetchJson(url, init={}, tries=3, retryDelay=600) {
      for (let t=0; t<tries; t++) {
        try {
          const r = await fetch(url, init);
          if (!r.ok) throw new Error("HTTP " + r.status + " " + (await r.text()));
          return await r.json();
        } catch (e) {
          if (t === tries-1) throw e;
          await new Promise(res => setTimeout(res, retryDelay * (t+1)));
        }
      }
    }

    async function getBinancePerpUSDT() {
      const info = await fetchJson("https://fapi.binance.com/fapi/v1/exchangeInfo");
      const syms = info.symbols
        .filter(s => s.contractType === "PERPETUAL" && s.quoteAsset === "USDT" && s.status === "TRADING")
        .map(s => ({ symbol: s.symbol, base: s.baseAsset, quote: s.quoteAsset }));
      const bad = /UP|DOWN|BULL|BEAR|[0-9]{3,}|HALF|HEDGE|ETHFI0|TEST|DOM/i;
      return syms.filter(s => !bad.test(s.base));
    }

    async function getCoinGeckoMcaps(minUSDm = 200) {
      const minCap = minUSDm * 1e6;
      const pages = [1, 2, 3];
      const results = [];
      for (const p of pages) {
        const url = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=250&page=${p}&price_change_percentage=24h`;
        results.push(...await fetchJson(url));
      }
      const map = new Map();
      for (const c of results) {
        if (!c.symbol || c.market_cap == null) continue;
        const key = String(c.symbol).toUpperCase();
        const prev = map.get(key);
        if (!prev || (c.market_cap || 0) > (prev.market_cap || 0)) {
          map.set(key, c);
        }
      }
      return {
        map,
        pass: sym => {
          const it = map.get(String(sym).toUpperCase());
          return it && (it.market_cap || 0) >= minCap;
        }
      };
    }

    async function getKlines(symbol, interval="1d", limit=200) {
      const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
      const rows = await fetchJson(url);
      return rows.map(r => ({
        openTime: r[0], open: +r[1], high: +r[2], low: +r[3], close: +r[4], volume: +r[5], closeTime: r[6]
      }));
    }

    async function pool(items, limit, worker) {
      const ret = [];
      let i = 0, active = 0;
      return new Promise((resolve) => {
        const next = () => {
          if (i >= items.length && active === 0) return resolve(ret);
          while (active < limit && i < items.length) {
            const idx = i++;
            active++;
            Promise.resolve(worker(items[idx], idx))
              .then(v => (ret[idx] = v))
              .catch(e => (ret[idx] = { error: String(e) }))
              .finally(() => { active--; next(); });
          }
        };
        next();
      });
    }

    let sortKey = "rsi";
    let sortAsc = false;
    function applySort(rows) {
      const key = sortKey;
      const asc = sortAsc ? 1 : -1;
      rows.sort((a,b) => {
        const va = a[key], vb = b[key];
        if (va == null && vb == null) return 0;
        if (va == null) return 1;
        if (vb == null) return -1;
        if (typeof va === "number" && typeof vb === "number") return asc * (va - vb);
        return asc * String(va).localeCompare(String(vb));
      });
    }

    function renderCrossCell(dir, level) {
      if (!dir) return `<span class="pill">—</span>`;
      const arrow = dir === "up" ? "↑" : "↓";
      const cls = dir === "up" ? "up" : "down";
      return `<span class="pill ${cls}" title="RSI ${dir} cross ${level}">${arrow} ${level}</span>`;
    }

    async function run() {
      const status = document.getElementById("status");
      const tbody = document.querySelector("#tbl tbody");
      const mcapSel = document.getElementById("mcap");
      const limitSel = document.getElementById("limit");
      const onlyCrossesEl = document.getElementById("onlyCrosses");
      const mode = document.getElementById("mode").value;
      const period = Math.max(2, Math.min(100, Number(document.getElementById("period").value || 14)));
      document.getElementById("thRsi").textContent = `RSI(${period}) D1`;

      const minUSDm = Number(mcapSel.value);
      const maxRows = Number(limitSel.value);

      status.textContent = `Loading symbols …`;
      const binanceSyms = await getBinancePerpUSDT();

      status.textContent = `Loading market caps …`;
      const mcap = await getCoinGeckoMcaps(minUSDm);

      const candidates = binanceSyms.filter(s => mcap.pass(s.base));
      status.textContent = `Fetching data for ${candidates.length} symbols …`;

      const rows = [];

      if (mode === "d1_only") {
        const results = await pool(candidates, 5, async s => {
          const d1 = await getKlines(s.symbol, "1d", 220);
          return { s, d1 };
        });

        for (const item of results) {
          if (!item || item.error || !item.d1 || item.d1.length < period + 2) continue;
          const closesD1 = item.d1.map(k => k.close);
          const rsiPrev = rsiAt(closesD1, closesD1.length - 1, period);
          const rsiCurr = rsiAt(closesD1, closesD1.length, period);
          const last = item.d1[item.d1.length - 1];
          const prev = item.d1[item.d1.length - 2];
          const cross30 = crossDir(rsiPrev, rsiCurr, 30);
          const cross50 = crossDir(rsiPrev, rsiCurr, 50);
          const cross70 = crossDir(rsiPrev, rsiCurr, 70);
          rows.push({
            symbol: item.s.symbol,
            base: item.s.base,
            rsi: rsiCurr,
            rsiPrev,
            close: last.close,
            prevClose: prev.close,
            chg: ((last.close - prev.close) / prev.close) * 100,
            time: last.closeTime,
            spark: closesD1.slice(-30),
            cross30, cross50, cross70,
            crossScore: ((cross30?1:0)+(cross50?1:0)+(cross70?1:0))
          });
        }
      } else {
        const results = await pool(candidates, 4, async s => {
          const [d1, h4] = await Promise.all([
            getKlines(s.symbol, "1d", 220),
            getKlines(s.symbol, "4h", 480)
          ]);
          return { s, d1, h4 };
        });

        for (const item of results) {
          if (!item || item.error || !item.d1 || item.d1.length < 3 || !item.h4 || item.h4.length < period + 2) continue;

          // Last fully closed D1 day
          const lastDay = item.d1[item.d1.length - 1];
          const prevDay = item.d1[item.d1.length - 2];
          const dayOpen = prevDay.closeTime;       // previous D1 close time == current D1 open
          const dayClose = lastDay.closeTime;      // last closed daily close time

          // D1 RSI value for display
          const closesD1 = item.d1.map(k => k.close);
          const rsiD1 = rsiAt(closesD1, closesD1.length, period);

          // H4 RSI series
          const closesH4 = item.h4.map(k => k.close);
          const rsiH4 = rsiSeries(closesH4, period);

          // Scan H4 bars inside last closed D1 day for any level cross
          let cross30 = null, cross50 = null, cross70 = null;
          for (let i = 1; i < item.h4.length; i++) {
            const prevBar = item.h4[i-1];
            const currBar = item.h4[i];
            if (!(currBar.closeTime > dayOpen && currBar.closeTime <= dayClose)) continue;
            const p = rsiH4[i-1], c = rsiH4[i];
            const d30 = crossDir(p, c, 30);
            const d50 = crossDir(p, c, 50);
            const d70 = crossDir(p, c, 70);
            if (d30) cross30 = d30; // keep latest cross within the day
            if (d50) cross50 = d50;
            if (d70) cross70 = d70;
          }

          rows.push({
            symbol: item.s.symbol,
            base: item.s.base,
            rsi: rsiD1,                 // display D1 RSI(14) at daily close
            rsiPrev: rsiAt(closesD1, closesD1.length - 1, period),
            close: lastDay.close,
            prevClose: prevDay.close,
            chg: ((lastDay.close - prevDay.close) / prevDay.close) * 100,
            time: lastDay.closeTime,
            spark: closesD1.slice(-30),
            cross30, cross50, cross70,
            crossScore: ((cross30?1:0)+(cross50?1:0)+(cross70?1:0))
          });
        }
      }

      // Enrich with CoinGecko market caps and 24h change if available
      for (const r of rows) {
        const cg = mcap.map.get(r.base.toUpperCase());
        r.mcap = cg ? cg.market_cap : null;
        if (cg && typeof cg.price_change_percentage_24h === "number") {
          r.chg = cg.price_change_percentage_24h;
        }
      }

      const minCapAbs = minUSDm * 1e6;
      let filtered = rows.filter(r => (r.mcap || 0) >= minCapAbs);
      if (onlyCrossesEl.checked) {
        filtered = filtered.filter(r => r.cross30 || r.cross50 || r.cross70);
      }

      applySort(filtered);
      const limited = filtered.slice(0, maxRows);

      const tbody = document.querySelector("#tbl tbody");
      tbody.innerHTML = "";
      for (const r of limited) {
        const tr = document.createElement("tr");
        const tvSym = `${r.base}USDT.P`;
        const tvUrl = `https://www.tradingview.com/chart/?symbol=BINANCE:${encodeURIComponent(tvSym)}`;
        const binUrl = `https://www.binance.com/en/futures/${encodeURIComponent(r.symbol)}`;
        const rsiClass = r.rsi != null ? (r.rsi <= 30 ? "green" : r.rsi >= 70 ? "red" : "yellow") : "";
        tr.innerHTML = `
          <td>
            <div style="display:flex;align-items:center;gap:8px;">
              <span class="status" style="background:${r.chg >= 0 ? 'var(--good)' : 'var(--bad)'}"></span>
              <a href="${binUrl}" target="_blank" rel="noopener">${r.symbol}</a>
              <span class="tag">USDT.P</span>
              <a href="${tvUrl}" target="_blank" rel="noopener" title="Open in TradingView">TV</a>
            </div>
          </td>
          <td class="mono ${rsiClass}">${r.rsi == null ? "-" : r.rsi.toFixed(2)}</td>
          <td class="mono">${fmtNum(r.close)}</td>
          <td class="mono ${r.chg >= 0 ? 'green' : 'red'}">${fmtPct(r.chg)}</td>
          <td class="mono">${fmtUSD(r.mcap)}</td>
          <td class="mono">${utcDateTime(r.time)}</td>
          <td>${renderCrossCell(r.cross30, 30)}</td>
          <td>${renderCrossCell(r.cross50, 50)}</td>
          <td>${renderCrossCell(r.cross70, 70)}</td>
          <td><canvas class="spark"></canvas></td>
        `;
        tbody.appendChild(tr);
        const canvas = tr.querySelector("canvas");
        drawSpark(canvas, r.spark);
      }

      document.getElementById("count").textContent =
        `Showing ${limited.length} of ${filtered.length} matches (scanned ${candidates.length}). Mode: ${mode === "h4_in_d1" ? "H4→D1" : "D1 only"}, RSI(${period}).`;
      status.textContent = `Done at ${utcDateTime(Date.now())}`;
    }

    // Sorting handlers
    document.querySelectorAll("#tbl thead th").forEach(th => {
      th.addEventListener("click", () => {
        const key = th.getAttribute("data-key");
        if (!key) return;
        if (sortKey === key) sortAsc = !sortAsc;
        else { sortKey = key; sortAsc = key === "symbol"; }
        run().catch(e => {
          document.getElementById("status").textContent = "Error: " + e.message;
        });
      });
    });

    document.getElementById("calc").addEventListener("click", () => {
      document.getElementById("status").textContent = "Calculating…";
      run().catch(e => {
        document.getElementById("status").textContent = "Error: " + e.message;
      });
    });

    document.getElementById("status").textContent = "Choose mode and click Calculate";
  </script>
</body>
</html>
