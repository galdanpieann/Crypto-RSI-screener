<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Crypto RSI(4) Screener — Binance USDT Perpetuals</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root { --bg:#0f1115; --panel:#151924; --text:#e6e6e6; --muted:#a0a7b4; --accent:#3ea6ff; --good:#2bb673; --bad:#e5534b; --warn:#ffbf3f; }
    body { background:var(--bg); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif; margin:0; padding:24px; }
    h1 { margin:0 0 8px; font-size:20px; }
    .sub { color:var(--muted); margin-bottom:16px; font-size:13px; }
    .panel { background:var(--panel); border-radius:10px; padding:16px; box-shadow:0 2px 10px rgba(0,0,0,.35); }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .ctrl { display:inline-flex; gap:8px; align-items:center; background:#0e121b; padding:8px 10px; border-radius:8px; }
    select, input { background:#0e121b; color:var(--text); border:1px solid #2a2f3a; border-radius:6px; padding:6px 8px; outline:none; }
    button { background:var(--accent); border:none; color:#061018; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:600; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    table { width:100%; border-collapse:collapse; font-size:13px; }
    thead th { text-align:left; color:var(--muted); font-weight:600; border-bottom:1px solid #2a2f3a; padding:10px 8px; cursor:pointer; user-select:none; white-space:nowrap; }
    tbody td { border-bottom:1px solid #202533; padding:10px 8px; vertical-align:middle; white-space:nowrap; }
    .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .tag { font-size:11px; color:#0b141a; background:#9ad3ff; padding:2px 6px; border-radius:999px; }
    .green { color:var(--good); }
    .red { color:var(--bad); }
    .yellow { color:var(--warn); }
    .spark { width:120px; height:28px; }
    .note { color:var(--muted); font-size:12px; margin-top:8px; }
    .loading { color:var(--muted); }
    .chip { background:#0e121b; border:1px solid #2a2f3a; padding:4px 8px; border-radius:999px; color:var(--muted); font-size:12px; }
    a { color:#7ec9ff; text-decoration:none; }
    a:hover { text-decoration:underline; }
    .status { display:inline-block; min-width:12px; min-height:12px; border-radius:999px; }
    .legend { display:inline-flex; gap:10px; align-items:center; font-size:12px; color:var(--muted); }
    .sig { display:inline-flex; gap:4px; align-items:center; }
  </style>
</head>
<body>
  <h1>Crypto RSI(4) Screener — Binance USDT Perpetuals</h1>
  <div class="sub">
    1D timeframe, last 4 fully closed candles. Market cap filter ≥ $200M (CoinGecko). Includes RSI crosses of 30 / 50 / 70.
    <div class="legend" style="margin-top:6px">
      <span>RSI bands:</span>
      <span class="chip">Oversold ≤ 30</span>
      <span class="chip">Neutral 30–70</span>
      <span class="chip">Overbought ≥ 70</span>
      <span class="chip">Cross tags: ↑30, ↑50, ↑70, ↓70, ↓50, ↓30</span>
    </div>
  </div>

  <div class="panel" style="margin-bottom:14px">
    <div class="row">
      <div class="ctrl">
        <label for="mcap">Min Market Cap</label>
        <select id="mcap">
          <option value="200" selected>≥ $200M</option>
          <option value="500">≥ $500M</option>
          <option value="1000">≥ $1B</option>
          <option value="5">≥ $5M</option>
          <option value="0">No filter</option>
        </select>
      </div>
      <div class="ctrl">
        <label for="limit">Max Rows</label>
        <select id="limit">
          <option>50</option>
          <option selected>100</option>
          <option>200</option>
          <option>500</option>
        </select>
      </div>
      <div class="ctrl">
        <label>RSI Period</label>
        <span class="chip">4</span>
      </div>
      <div class="ctrl">
        <label for="crossOnly">Cross Filter</label>
        <select id="crossOnly">
          <option value="none" selected>Show all</option>
          <option value="any">Only crosses</option>
          <option value="up">Only cross-ups (↑)</option>
          <option value="down">Only cross-downs (↓)</option>
        </select>
      </div>
      <button id="refresh">Refresh</button>
      <span id="status" class="loading">Loading…</span>
    </div>
    <div class="note">
      Data: Binance USDⓈ-M Perpetual (1d klines) and CoinGecko market caps. Times shown in UTC. Uses only completed daily candles.
    </div>
  </div>

  <div class="panel">
    <table id="tbl">
      <thead>
        <tr>
          <th data-key="symbol">Symbol</th>
          <th data-key="rsi" data-num>RSI(4)</th>
          <th data-key="cross">RSI Cross</th>
          <th data-key="close" data-num>Last Close</th>
          <th data-key="chg" data-num>24h</th>
          <th data-key="mcap" data-num>Market Cap</th>
          <th data-key="time" data-num>Last Close Time</th>
          <th>Sparkline</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
    <div class="note" id="count"></div>
  </div>

  <script>
    const fmtUSD = n => {
      if (n == null || isNaN(n)) return "-";
      if (n >= 1e12) return "$" + (n/1e12).toFixed(2) + "T";
      if (n >= 1e9) return "$" + (n/1e9).toFixed(2) + "B";
      if (n >= 1e6) return "$" + (n/1e6).toFixed(2) + "M";
      if (n >= 1e3) return "$" + (n/1e3).toFixed(2) + "K";
      return "$" + n.toFixed(2);
    };
    const fmtNum = n => (n == null || isNaN(n) ? "-" : n.toLocaleString(undefined, {maximumFractionDigits: 6}));
    const fmtPct = n => (n == null || isNaN(n) ? "-" : (n >= 0 ? "+" : "") + n.toFixed(2) + "%");
    const utcDateTime = ms => new Date(ms).toISOString().replace("T", " ").replace(/\..+/, " UTC");

    function drawSpark(canvas, arr) {
      const ctx = canvas.getContext("2d");
      const w = canvas.width = canvas.clientWidth;
      const h = canvas.height = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);
      if (!arr || arr.length < 2) return;
      const min = Math.min(...arr), max = Math.max(...arr);
      const norm = v => (h - 2) - ((v - min) / (max - min || 1)) * (h - 4);
      ctx.lineWidth = 2;
      const grad = ctx.createLinearGradient(0,0,w,0);
      const lastUp = arr[arr.length - 1] >= arr[0];
      grad.addColorStop(0, lastUp ? "#46d990" : "#ff7e7e");
      grad.addColorStop(1, lastUp ? "#12a66d" : "#d34242");
      ctx.strokeStyle = grad;
      ctx.beginPath();
      arr.forEach((v, i) => {
        const x = (i/(arr.length-1)) * (w-4) + 2;
        const y = norm(v);
        if (i === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.stroke();
    }

    // Wilder RSI series (period=4) and last two values
    function rsiSeries(closes, period = 4) {
      if (!closes || closes.length < period + 1) return [];
      const deltas = [];
      for (let i=1;i<closes.length;i++) deltas.push(closes[i]-closes[i-1]);
      let gains = 0, losses = 0;
      for (let i=0;i<period;i++) {
        const d = deltas[i];
        if (d >= 0) gains += d; else losses -= d;
      }
      let avgGain = gains / period;
      let avgLoss = losses / period;
      const rsis = [];
      // First RSI at index = period
      rsis.push(avgLoss === 0 ? 100 : 100 - (100/(1 + (avgGain/avgLoss))));
      for (let i=period; i<deltas.length; i++) {
        const d = deltas[i];
        const gain = d > 0 ? d : 0;
        const loss = d < 0 ? -d : 0;
        avgGain = (avgGain * (period - 1) + gain) / period;
        avgLoss = (avgLoss * (period - 1) + loss) / period;
        rsis.push(avgLoss === 0 ? 100 : 100 - (100/(1 + (avgGain/avgLoss))));
      }
      return rsis; // aligned to closes index starting at position 'period'
    }

    function crossTags(prev, curr) {
      const tags = [];
      const levels = [30, 50, 70];
      for (const L of levels) {
        if (prev < L && curr >= L) tags.push(`↑${L}`);
        if (prev > L && curr <= L) tags.push(`↓${L}`);
      }
      return tags;
    }

    async function fetchJson(url, init={}, tries=3, retryDelay=600) {
      for (let t=0; t<tries; t++) {
        try {
          const r = await fetch(url, init);
          if (!r.ok) throw new Error("HTTP " + r.status + " " + (await r.text()).slice(0,200));
          return await r.json();
        } catch (e) {
          if (t === tries-1) throw e;
          await new Promise(res => setTimeout(res, retryDelay * (t+1)));
        }
      }
    }

    async function getBinancePerpUSDT() {
      const info = await fetchJson("https://fapi.binance.com/fapi/v1/exchangeInfo");
      const syms = info.symbols
        .filter(s => s.contractType === "PERPETUAL" && s.quoteAsset === "USDT" && s.status === "TRADING")
        .map(s => ({ symbol: s.symbol, base: s.baseAsset, quote: s.quoteAsset });
      const bad = /UP|DOWN|BULL|BEAR|[0-9]{3,}|HALF|HEDGE|BTCDOM|TEST/i;
      return syms.filter(s => !bad.test(s.base));
    }

    async function getCoinGeckoMcaps(minUSDm = 200) {
      const minCap = minUSDm * 1e6;
      const pages = [1, 2, 3];
      const results = [];
      for (const p of pages) {
        const url = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=250&page=${p}&price_change_percentage=24h`;
        results.push(...await fetchJson(url));
      }
      const map = new Map();
      for (const c of results) {
        if (!c.symbol || c.market_cap == null) continue;
        const key = String(c.symbol).toUpperCase();
        const prev = map.get(key);
        if (!prev || (c.market_cap || 0) > (prev.market_cap || 0)) map.set(key, c);
      }
      return {
        map,
        pass: sym => {
          const it = map.get(String(sym).toUpperCase());
          return it && (it.market_cap || 0) >= minCap;
        }
      };
    }

    async function getDailyKlines(symbol, limit=200) {
      const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=1d&limit=${limit}`;
      const rows = await fetchJson(url);
      return rows.map(r => ({ openTime:r[0], open:+r[1], high:+r[2], low:+r[3], close:+r[4], volume:+r[5], closeTime:r[6] }));
    }

    async function pool(items, limit, worker) {
      const ret = [];
      let i = 0, active = 0;
      return new Promise((resolve) => {
        const next = () => {
          if (i >= items.length && active === 0) return resolve(ret);
          while (active < limit && i < items.length) {
            const idx = i++;
            active++;
            Promise.resolve(worker(items[idx], idx))
              .then(v => (ret[idx] = v))
              .catch(e => (ret[idx] = { error: String(e) }))
              .finally(() => { active--; next(); });
          }
        };
        next();
      });
    }

    let sortKey = "rsi";
    let sortAsc = false;
    function applySort(rows) {
      const key = sortKey; const asc = sortAsc ? 1 : -1;
      rows.sort((a,b) => {
        const va = a[key], vb = b[key];
        if (va == null && vb == null) return 0;
        if (va == null) return 1; if (vb == null) return -1;
        if (typeof va === "number" && typeof vb === "number") return asc * (va - vb);
        return asc * String(va).localeCompare(String(vb));
      });
    }

    async function run() {
      const status = document.getElementById("status");
      const tbody = document.querySelector("#tbl tbody");
      const mcapSel = document.getElementById("mcap");
      const limitSel = document.getElementById("limit");
      const crossSel = document.getElementById("crossOnly");
      const minUSDm = Number(mcapSel.value);
      const maxRows = Number(limitSel.value);
      const crossFilter = crossSel.value; // none|any|up|down

      status.textContent = "Loading symbols …";
      const binanceSyms = await getBinancePerpUSDT();

      status.textContent = `Loading market caps …`;
      const mcap = await getCoinGeckoMcaps(minUSDm);

      const candidates = binanceSyms.filter(s => mcap.pass(s.base));
      status.textContent = `Fetching klines for ${candidates.length} symbols …`;

      const klinesAll = await pool(candidates, 6, async s => {
        const kl = await getDailyKlines(s.symbol, 200);
        return { s, kl };
      });

      const rows = [];
      for (const item of klinesAll) {
        if (!item || item.error || !item.kl || item.kl.length < 10) continue;
        const closes = item.kl.map(k => k.close);
        const rsis = rsiSeries(closes, 4);
        if (!rsis || rsis.length < 2) continue;
        const last = item.kl[item.kl.length - 1];
        const prev = item.kl[item.kl.length - 2];
        const rsiCurr = rsis[rsis.length - 1];
        const rsiPrev = rsis[rsis.length - 2];
        const tags = crossTags(rsiPrev, rsiCurr);
        if (crossFilter === 'any' && tags.length === 0) continue;
        if (crossFilter === 'up' && !tags.some(t => t.startsWith('↑'))) continue;
        if (crossFilter === 'down' && !tags.some(t => t.startsWith('↓'))) continue;
        const spark = closes.slice(-30);
        rows.push({
          symbol: item.s.symbol,
          base: item.s.base,
          rsi: rsiCurr,
          rsiPrev,
          cross: tags,
          close: last.close,
          prevClose: prev.close,
          chg: ((last.close - prev.close) / prev.close) * 100,
          time: last.closeTime,
          spark
        });
      }

      for (const r of rows) {
        const cg = mcap.map.get(r.base.toUpperCase());
        r.mcap = cg ? cg.market_cap : null;
        if (cg && typeof cg.price_change_percentage_24h === "number") r.chg = cg.price_change_percentage_24h;
      }

      const minCapAbs = minUSDm * 1e6;
      const filtered = rows.filter(r => (r.mcap || 0) >= minCapAbs);

      applySort(filtered);
      const limited = filtered.slice(0, maxRows);

      tbody.innerHTML = "";
      for (const r of limited) {
        const tr = document.createElement("tr");
        const tvSym = `${r.base}USDT.P`;
        const tvUrl = `https://www.tradingview.com/chart/?symbol=BINANCE:${encodeURIComponent(tvSym)}`;
        const binUrl = `https://www.binance.com/en/futures/${encodeURIComponent(r.symbol)}`;
        const rsiClass = r.rsi != null ? (r.rsi <= 30 ? "green" : r.rsi >= 70 ? "red" : "yellow") : "";
        const crossHtml = r.cross && r.cross.length ? r.cross.map(t => `<span class="tag">${t}</span>`).join(' ') : '-';
        tr.innerHTML = `
          <td>
            <div style="display:flex;align-items:center;gap:8px;">
              <span class="status" style="background:${r.chg >= 0 ? 'var(--good)' : 'var(--bad)'}"></span>
              <a href="${binUrl}" target="_blank" rel="noopener">${r.symbol}</a>
              <span class="tag">USDT.P</span>
              <a href="${tvUrl}" target="_blank" rel="noopener" title="Open in TradingView">TV</a>
            </div>
          </td>
          <td class="mono ${rsiClass}">${r.rsi == null ? "-" : r.rsi.toFixed(2)}</td>
          <td>${crossHtml}</td>
          <td class="mono">${fmtNum(r.close)}</td>
          <td class="mono ${r.chg >= 0 ? 'green' : 'red'}">${fmtPct(r.chg)}</td>
          <td class="mono">${fmtUSD(r.mcap)}</td>
          <td class="mono">${utcDateTime(r.time)}</td>
          <td><canvas class="spark"></canvas></td>
        `;
        tbody.appendChild(tr);
        const canvas = tr.querySelector("canvas");
        drawSpark(canvas, r.spark);
      }

      document.getElementById("count").textContent =
        `Showing ${limited.length} of ${filtered.length} matches (scanned ${candidates.length} candidates).`;
      status.textContent = `Done at ${utcDateTime(Date.now())}`;
    }

    document.querySelectorAll("#tbl thead th").forEach(th => {
      th.addEventListener("click", () => {
        const key = th.getAttribute("data-key");
        if (!key) return;
        if (sortKey === key) sortAsc = !sortAsc; else { sortKey = key; sortAsc = key === "symbol"; }
        run().catch(e => { document.getElementById("status").textContent = "Error: " + e.message; });
      });
    });

    document.getElementById("refresh").addEventListener("click", () => {
      document.getElementById("status").textContent = "Refreshing…";
      run().catch(e => { document.getElementById("status").textContent = "Error: " + e.message; });
    });

    document.getElementById("mcap").addEventListener("change", () => { document.getElementById("status").textContent = "Updating…"; run().catch(e => { document.getElementById("status").textContent = "Error: " + e.message; }); });
    document.getElementById("limit").addEventListener("change", () => { document.getElementById("status").textContent = "Updating…"; run().catch(e => { document.getElementById("status").textContent = "Error: " + e.message; }); });
    document.getElementById("crossOnly").addEventListener("change", () => { document.getElementById("status").textContent = "Updating…"; run().catch(e => { document.getElementById("status").textContent = "Error: " + e.message; }); });

    run().catch(e => { document.getElementById("status").textContent = "Error: " + e.message; });
  </script>
</body>
</html>
